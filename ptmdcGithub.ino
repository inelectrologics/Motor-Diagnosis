//
// Copyright by Pat Taweewat, PTMDC2 for Paper II at iEECON 2025: Covering adc,wifi,serial communication on MCU and PC.
// This code is modified from my previous seminar projects to suite paper MCU platfrom for motor diagnosis and data
// acquisition.
// The machine learning part is modified from the example provided by EloquentML library example at
// https://github.com/eloquentarduino/EloquentTinyML.
// Please ensure that memory sizes both flash and RAM is suitable on your ESP32 board as I used ESP32-C3 4MB flash Dual USB board.
//
#include "esp_system.h"
#include <WiFi.h>
const char* ssid="wifirouter";// This is just my dummy router name. Please provide your own router name.
const char* password="password";// This is just my dummy password. Please provide your own.
const uint16_t port=80;
const char* ssidap="motor-server";
const char* passwordap="motorappassword";
char server_on=0;
WiFiServer server(port);
#include "arduinoFFT.h"
#include <EloquentTinyML.h>
#include <eloquent_tinyml/tensorflow.h>

// Model value is saved in code generated by Python with xxd/tinymlgen
#include "ptmdc_model.h"

#define N_INPUTS 192
#define N_OUTPUTS 3
#define TENSOR_ARENA_SIZE 2*1024
const uint16_t adcbufsize=32768;
uint16_t adcbuf[adcbufsize];
uint8_t mbuf[10000];
const uint16_t samples=4096;
const double sampling=5000;
double vReal[samples];
double vImag[samples];
uint16_t idx;
byte inBytes[8];
byte wchoich;
double dval;
uint16_t aval;
uint16_t tflmSz;
uint8_t bval;
uint8_t *loadedModel;
ArduinoFFT<double> FFT=ArduinoFFT<double>(vReal,vImag,samples,sampling);
//EloquentML::TinyML::TfLite<N_INPUTS, N_OUTPUTS, TENSOR_ARENA_SIZE> tf;
Eloquent::TinyML::TensorFlow::TensorFlow<N_INPUTS, N_OUTPUTS, TENSOR_ARENA_SIZE> tf;

float xbuf[192],sfbuf[192];
float ybuf[3],yprd[3];
int sfi,chi;
char chip=-1;//char variable
byte dtcount=0;//just to make value run for testing only
void loadModel(void);
void setup() {
    Serial.begin(115200);
    Serial.println("Please See my example by Pat Taweewat");
    Serial.println("send 1 to load model, 2 to predict");  
    Serial.print("Test");
    delay(3000);
}

void loop() {
  chi=0;
  String stch="";
  while(Serial.available()>0){
    chip=Serial.read();
    if (chip!='\0'){
      stch+=chip;
      chi++;      
    }
    if (chip=='\0'){
      stch+='\0';
      break;
    }
  }
 if(stch.charAt(0)=='x'){// put value to xbuf[i]
  xbuf[sfi]=stch.substring(1).toFloat();
  Serial.println(xbuf[sfi]);
  sfi=sfi+1;
 }
 else if(stch.charAt(0)=='i'){// assign i position
  sfi=stch.substring(1).toInt();
  Serial.println(sfi);  
 }
 else if(stch.charAt(0)=='y'){// put value to ybuf[i]
  ybuf[sfi]=stch.substring(1).toInt();
  Serial.println(ybuf[sfi]);
  sfi=sfi+1;
 }
 else if(stch.charAt(0)=='c'){// show all xbuf value
  for(int i=0;i<96;i++){
    Serial.println(xbuf[i],3);    
  }
 }
 else if(stch.charAt(0)=='l'){// load model
      Serial.println("loading model...");
      loadModel();
      if (!tf.begin(loadedModel)) {
        Serial.println("Cannot inialize model");
        Serial.println(tf.getErrorMessage());
        delay(60000);
      }
      Serial.println("OK");
      Serial.println(ESP.getFreeHeap());
      Serial.println(ESP.getHeapSize());
 }
 else if(stch.charAt(0)=='p'){// predict
        Serial.print("xbuf -> is predicted ");
        Serial.println(tf.predictClass(xbuf));
        Serial.println(tf.probaToClass(xbuf));
        uint32_t tstart=micros();
        float y0=tf.predict(xbuf,yprd);
        uint32_t timeused=micros()-tstart;
        Serial.println(tf.predict(xbuf));
        Serial.println("direct predicted");
        Serial.print(yprd[0]);Serial.print(":");
        Serial.print(yprd[1]);Serial.print(":");
        Serial.print(yprd[2]);
        Serial.print(" vs ");
        Serial.print(ybuf[0]);Serial.print(":");
        Serial.print(ybuf[1]);Serial.print(":");
        Serial.print(ybuf[2]);      
        Serial.print(" actual outputs");
        Serial.print(" Process used ");Serial.print(timeused);Serial.println("micro Secs.");
        delay(500);  
 }
 else if((stch.charAt(0)=='a')&&(stch.charAt(1)=='i')){//adc read into mcu memory
  unsigned long tstart=micros();
  for(int i=0;i<adcbufsize;i++){
    adcbuf[i]=analogRead(0);delayMicroseconds(200-55);
  }
  unsigned long tlast=micros();
  unsigned long tused=tlast-tstart;
  Serial.print("Start time:");
  Serial.println(tstart);
  Serial.print("Last time: ");
  Serial.println(tlast);
  Serial.print("Time used: ");
  Serial.println(tused);
  Serial.print("Per sample:");
  Serial.println(double(tused)/adcbufsize);
 }
 else if((stch.charAt(0)=='a')&&(stch.charAt(1)=='f')){//adc->fft->pc
  unsigned long tstart=micros();
  for(int i=0;i<samples;i++){
    adcbuf[i]=analogRead(0);delayMicroseconds(200-55);
  }
  for(int i=0;i<samples;i++){//adc->fft
    vReal[i]=double(adcbuf[i]);
    vImag[i]=0.0;
  }
  FFT.windowing(FFTWindow::Hann, FFTDirection::Forward);//compute FFT
  FFT.compute(FFTDirection::Forward);
  FFT.complexToMagnitude();
  for(int i=0;i<samples;i++){
    Serial.println(adcbuf[i]);
  }
  delay(100);
  uint16_t hsamples=samples>>1;
  for (int i=0;i<hsamples;i++){
    Serial.println(vReal[i]);
  }
 }

  else if(stch.charAt(0)=='r'){//read test
  delay(1000);
  unsigned long tstart=micros();  
  for(int j=0;j<10;j++){
    for(int i=0;i<adcbufsize;i++){
     Serial.println(adcbuf[i]);
   }
  }
  unsigned long tlast=micros();
  unsigned long tused=tlast-tstart;
  Serial.print("Start time:");
  Serial.println(tstart);
  Serial.print("Last time: ");
  Serial.println(tlast);
  Serial.print("Time used: ");
  Serial.println(tused);
  Serial.print("Per sample:");
  Serial.println((double(tused)/adcbufsize)/10);
 }
  else if(stch.charAt(0)=='d'){//download
  delay(1000);
  unsigned long tstart=micros();  
    for(int i=0;i<adcbufsize;i++){
     Serial.println(adcbuf[i]);
   }
  unsigned long tlast=micros();
  unsigned long tused=tlast-tstart;
  Serial.print("Start time:");
  Serial.println(tstart);
  Serial.print("Last time: ");
  Serial.println(tlast);
  Serial.print("Time used: ");
  Serial.println(tused);
  Serial.print("Per sample:");
  Serial.println((double(tused)/adcbufsize));
 }
  else if(stch.charAt(0)=='e'){//load ADC to FFT buffer
    for(int i=0;i<samples;i++){
      vReal[i]=double(adcbuf[i]);
      vImag[i]=0.0;
    }
    Serial.println("Finish adc->fft buffer");
  }
  else if(stch.charAt(0)=='f'){//compute FFT
  FFT.windowing(FFTWindow::Hann, FFTDirection::Forward);
  FFT.compute(FFTDirection::Forward);
  FFT.complexToMagnitude();
  uint16_t hsamples=samples>>1;
  for (int i=0;i<hsamples;i++){
    Serial.println(vReal[i]);
  }Serial.println('FFT computed');
 }
  else if(stch.charAt(0)=='v'){//download FFT
  delay(1000);
  unsigned long tstart=micros();
  uint16_t hsamples=samples>>1;
    for(int i=0;i<hsamples;i++){
     Serial.println(vReal[i]);
   }
  unsigned long tlast=micros();
  unsigned long tused=tlast-tstart;
  Serial.print("Length:");
  Serial.println(hsamples);
  Serial.print("Start time:");
  Serial.println(tstart);
  Serial.print("Last time: ");
  Serial.println(tlast);
  Serial.print("Time used: ");
  Serial.println(tused);
  Serial.print("Per sample:");
  Serial.println((double(tused)/adcbufsize));
  }
  else if(stch.charAt(0)=='t'){//FFT upload
    delay(10);
    idx=0;
    while(idx<2048){
     if(Serial.available()==8){
      Serial.readBytes(inBytes,8);
      memcpy(&dval,inBytes,8);
      vReal[idx]=dval;
      idx++;
    }
   }Serial.println("FFT uploaded");
  }
  else if(stch.charAt(0)=='u'){//upload adc
   adcbuf[sfi]=stch.substring(1).toInt();
   Serial.println(adcbuf[sfi]);
   sfi=sfi+1;
  }
  else if(stch.charAt(0)=='b'){// show all adcbuf value
   for(int i=0;i<4096;i++){
    Serial.println(adcbuf[i]);    
  }
 }
  else if(stch.charAt(0)=='g'){// show all fftbuf value
   for(int i=0;i<2048;i++){
    Serial.println(vReal[i]);
  }
 }
  else if(stch.charAt(0)=='w'){
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("Connected to WiFi");
  
  // Start the server
  server.begin();
  Serial.print("ESP32 IP address: ");
  Serial.println(WiFi.localIP());
   
   server_on=1;
   if(stch.charAt(1)=='0'){
    WiFi.disconnect(true);
    WiFi.mode(WIFI_OFF);
    server_on=0;
    Serial.println("Now off");
   }else if(stch.charAt(1)=='2'){
    server_on=2;
    Serial.println("Disp HTML");
   }else if(stch.charAt(1)=='3'){
    server_on=3;
   }
  }
  if(server_on==1){
   WiFiClient client=server.available();
   if(client){
    Serial.println("Client connected");
    String ccstr="";
      while(client.available()){
        char cc=client.read();
        if(cc!='\0'){
          ccstr+=cc;
          //chi++;      
        }
        if(cc=='\0'){
          ccstr+='\0';
          break;
        }
      }
      Serial.println(ccstr);
      if(ccstr.charAt(0)=='d'){
        delay(1000);
        Serial.println("Ask to download");
        client.println("DATA1234567890");
      }
      client.stop();
   }
  }else if(server_on==2){
    WiFiClient client=server.available();
    if(client){
    Serial.println("New Client Connected");
    String req="";
    while(client.available()){
      char c=client.read();
      req+=c;
    }
    if(req.indexOf("GET / ")>=0){
     client.println("HTTP/1.1 200 OK");
     client.println("Content-type:text/html");
     client.println("Cache-Control: no-store");
     client.println("Connection: close");
     client.println("Access-Control-Allow-Origin: *");
     client.println();
     client.println("<!DOCTYPE html><html>");
     client.println("<script>");
     client.println("setInterval(function() {");
     client.println("  fetch('/adc')");  // Request the ADC value from ESP32
     client.println("    .then(response => response.text())");
     client.println("    .then(data => {");
     client.println("      document.getElementById('adc_value').innerText = data;"); 
     client.println("  });");
     client.println("}, 5000);");  // Refresh every 10 seconds
     client.println("</script>");
     client.println("<body>");
     client.println("<h1>ESP32 Motor Health</h1>");
     client.println("<p>ADC value: <span id='adc_value'>Loading...</span></p>");
     client.println("<p><a href=\"/d\">Download ADC</a></p>");
     client.println("<p><a href=\"/f\">Download FFT</a></p>");     
     client.println("<p> provided by Pat Taweewat</p>");
     client.println("</body>");
     client.println("</html>");
    }else if(req.indexOf("GET /d")>=0){
     client.println("HTTP/1.1 200 OK");
     client.println("Content-Type: text/plain");
     client.println("Content-Disposition: attachment; filename=adt.csv");
     client.println("Cache-Control: no-store");
     client.println("Connection: close");
     client.println();
     for(int i=0;i<4096;i++){
      client.println(adcbuf[i]);
     }
    }else if(req.indexOf("GET /f")>=0){
     client.println("HTTP/1.1 200 OK");
     client.println("Content-Type: text/plain");
     client.println("Content-Disposition: attachment; filename=fdt.csv");
     client.println("Cache-Control: no-store");
     client.println("Connection: close");
     client.println();
     for(int i=0;i<2048;i++){
      client.println(vReal[i]);
     }
    }else if(req.indexOf("GET /adc")>=0){
     client.println("HTTP/1.1 200 OK");
     client.println("Content-Type: text/plain");
     client.println("Cache-Control: no-store");
     client.println("Connection: close");
     client.println();
     client.println(dtcount);
    }
     client.stop();
     Serial.println("client disconnected");
   }
  }
  else if(server_on==3){ 
  WiFiClient client = server.available();
  if (client) {
    Serial.println("tcp client connected.");
    Serial.println(ESP.getFreeHeap());
    while(client.connected()){
      if(client.available()){
        Serial.println(client.available());
        wchoich=client.read();
        Serial.println(wchoich);
        if(wchoich=='u'){
         Serial.println("upload");
         idx=0;
          while(idx<2048){   
           if (client.available()>=8) {
            client.readBytes(inBytes,8);
            memcpy(&dval,inBytes,8);
            vReal[idx]=dval;
            idx++;  
           }
          }Serial.print(idx);
         }
         else if(wchoich=='d'){
          Serial.println("download");
          delay(1000);
          idx=0;
          while(idx<2048){
           dval=vReal[idx];
           client.write(reinterpret_cast<uint8_t*>(&dval),8);
           //client.println(dval);
           idx++;  
          }
         }
         else if(wchoich=='v'){
         Serial.println("upload adc");
         idx=0;
          while(idx<4096){   
           if (client.available()>=2) {
            client.readBytes(inBytes,2);
            memcpy(&aval,inBytes,2);
            adcbuf[idx]=aval;
            idx++;  
           }
          }Serial.print(idx);
         }
         else if(wchoich=='m'){
         client.readBytes(inBytes,2);
         memcpy(&tflmSz,inBytes,2);
         Serial.println("upload model");
         Serial.println(tflmSz);
         idx=0;
          while(idx<tflmSz){   
           if (client.available()>=1) {
            client.readBytes(inBytes,1);
            memcpy(&bval,inBytes,1);
            mbuf[idx]=bval;
            idx++;  
           }
          }Serial.print(idx);
         }
         client.stop();
         Serial.println("Client disconnected."); 
       }
    }
  }//client.stop();
 }
  
}


void loadModel() {
    size_t modelSize=tflmSz;
    Serial.print("Found model of size ");
    Serial.println(modelSize);

    loadedModel = (uint8_t*) malloc(modelSize);

    for (size_t i = 0; i < modelSize; i++)
      loadedModel[i]=mbuf[i];
    Serial.println(ESP.getFreeHeap());
    Serial.println(ESP.getHeapSize());
}
